#include <bits/stdc++.h>
#include <cassert>
typedef long long int ll;
using namespace std;
#define REP2(i, a, b) for (ll i = (a); i < (b); i++)
#define REP2R(i, a, b) for (ll i = (a); i >= (b); i--)
#define REP(i, b) REP2(i, 0, b)
#define ALL(coll) (coll).begin(), (coll).end()
#define SIZE(v) ((ll)((v).size()))

/*
  Skelton for Interactive Problems

  (1) Edit the following member functions in JudgeRem class 
      They are for adjusting the interface.
      - constructor
      - ask()   (or ask_q() and ask_a())
      - answer()
  (2) Write function game().  This is for writing your algorithm.
  (3) For hand debugging, compile and run.
  (4) For automated testing, do the following
  (4.1) Set the value of macro JUDGE_LOC to 1.
  (4.2) Edit JudgeLoc struct

  Testing
    (*) ./cans
       This is the true program.  You can manually input data into its
       stdin.
    (**) ./cans judge < din.txt
       One-shot testing.  The format of din.txt is not defined by the
       writer of the question.  You can freely set the spec for the input
       file so that JudgeLoc() can read the input.
    (***) cmpNaive -i -e -p './cans judge'
       cmpNaive testing.  Runs multiple times against test files
       generated by `gen' script.  A test run is regarded as a success
       if its exit code is zero.
 */

// @@ !! LIM()

// When you debug with JudgeLoc class, the value should be 1
#define JUDGE_LOC 0
// #define JUDGE_LOC 1

const string end_mark("^__=end=__^");

struct SolveExc : exception {};

void do_game(bool is_judge);

int main(int argc, char *argv[]) {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << setprecision(20);

  bool is_judge = false;
  if (argc == 2) {
    if (strcmp(argv[1], "judge") == 0) {
      is_judge = true;
    }else if (strcmp(argv[1], "skip") == 0) {
      return 0;
    }else {
      cerr << "Unknown argument" << endl;
      exit(1);
    }
  }
    
  try {
    do_game(is_judge);
  }catch (const SolveExc& e) {
  }
  return 0;
}

/* External variables, typically for values given as initial input. */
ll N;
vector<vector<ll>> nbr;
vector<ll> parent;
vector<ll> euler;

struct Judge {
  virtual ll ask(vector<ll> vec) = 0;
  virtual void answer(ll a, ll b) = 0;

  // Call ac() in JudgeLoc when the answer is correct.
  void ac() {
    cout << "AC" << endl;
    throw SolveExc();
  }

  // Call wa() in JudgeLoc when the answer is not correct.
  void wa() {
    cout << "WA" << endl;
    exit(1);
  }
};

#if JUDGE_LOC
// This is a class for local testing.
struct JudgeLoc : Judge {
  ll expected;    // Typically, expected answer is read in the beginning
                  // from the question-specifying file.

  JudgeLoc() {
    // Typically, read the question for testing from stdin
    /*
    cin >> N >> expected;
    */
  }

  // Returns the answer for a query x.
  ll ask(vector<ll> vec) {
    // An example for Guessing Number Game.
    /*
    if (x < expected)      return 1;
    else if (x > expected) return -1;
    else                   return 0;
    return ask_a_t();
    */
  }

  // Always call ac() or wa().
  void answer(ll a, ll b) {
    /*
    if (x == expected) ac();
    else wa();
    */
  }
};
#endif // JUDGE_LOC

// The class that implements interfaces to the external judge program.
struct JudgeRem : Judge {

  // Read initial information in the constructor.  
  // Typically you need to read a parameter
  // such as the size of the question.  You may want to define a global
  // variable, such as N, just the above of line of "struct Judge{".
  JudgeRem() {
    cin >> N;
    nbr.resize(N);
    parent.resize(N);
    REP(i, N-1) {
      ll u, v; cin >> u >> v; u--; v--;
      nbr[u].push_back(v);
      nbr[v].push_back(u);
    }
    auto dfs = [&](auto rF, ll nd, ll pt) -> void {
      parent[nd] = pt;
      for (ll cld : nbr[nd]) {
        if (cld == pt) continue;
        euler.push_back(cld);
        rF(rF, cld, nd);
        euler.push_back(cld);
      }
    };
    dfs(dfs, 0, -1);

    /*
    cin >> N;
    */
  }

  // Asks for and receives information
  ll ask(vector<ll> vec) {
    cout << "? " << SIZE(vec);
    for (ll v : vec) cout << " " << v + 1;
    cout << endl;
    ll x; cin >> x;
    return x;
  }
  /*
  An example:
    bool ask(ll x, ll y) {
      cout << "? " << x << " " << y << endl;
      string ret; cin >> ret;
      return ret == "YES";
    }
  */

  // Final output.  Typically prepended by "! " and followed by endl
  // You need to throw SolveExc() at the end of the function.
  void answer(ll a, ll b) {
    cout << "! " << a+1 << " " << b+1 << endl;
    /*
    cout << "! " << x << endl;
    */
    throw SolveExc();
  }
};

vector<ll> nodes(ll left, ll right) {
  vector<ll> ret;
  vector<bool> added(N);
  auto add = [&](ll x) -> void {
    if (not added[x]) {
      added[x] = true;
      ret.push_back(x);
    }
  };
  for (ll i = left; i < right; i++) { add(euler[i]); add(parent[euler[i]]); }
  return ret;
}

// You write your algorithm using judge.ask()
// (or judge.ask_a() and judge.ask_q()).
// Note that you need to call judge.answer() to correctly terminate
// the program.
void game(Judge&& judge) {
  ll left = 0;
  ll right = SIZE(euler);
  ll vmax = judge.ask(nodes(left, right));
  while (right - left > 1) {
    ll mid = (left + right) / 2;
    ll v = judge.ask(nodes(left, mid));
    if (v == vmax) right = mid;
    else           left = mid;
  }
  ll i = euler[left];
  return judge.answer(i, parent[i]);

  /*
  // example for Guessing Number Game
  ll left = 1;
  ll right = sz;
  while (true) {
    ll mid = (left + right) / 2;
    ll reply = judge.ask(mid);
    if (reply == 0) judge.answer(mid);
    if (reply == -1) right = mid - 1;
    if (reply == 1)  left  = mid + 1;
  }
  */
}

// You should not edit this function.
void do_game(bool is_judge) {
#if JUDGE_LOC
  if (is_judge) game(JudgeLoc());
  else          game(JudgeRem());
#else
  game(JudgeRem());
#endif
}


