#include <bits/stdc++.h>
#include <cassert>
typedef long long int ll;
using namespace std;

/*
  interactive.cc -- skelton for interactive question

  (1) Copy the part just before the END mark of this file into the
      effective part.
  (2) Edit the following
    (2-1) three "using" definitions in abstract class judge
          They are used in the signatures of functions listed in (2-2).
    (2-2) For each of JudgeLoc and JudgeRem,
       (2-2-a) constructor
       (2-2-b) ask_q()
       (2-2-c) ask_a()
       (2-2-d) answer()
          Note that JudgeRem is a must.  This is for the true program.
          JudgeLoc is for a local testing, thus can be left (almost) as-is.
    (2-3) Function game()
          This is where you need to write the algorithm.
  (3) Testing
    (3-1) ./cans
       This is the true program.  You can manually input data into its
       stdin.
    (3-2) ./cans judge < din.txt
       One-shot testing.  The format of din.txt is not defined by the
       writer of the question.  You can freely set the spec for the input
       file so that JudgeLoc() can read the input.
    (3-3) cmpNaive -i -e -p './cans judge'
       cmpNaive testing.  Runs multiple times against test files
       generated by `gen' script.  A test run is regarded as a success
       if its exit code is zero.

 */

// @@ !! LIM()

//////////////////////////////////////////////////////////////////////
// See help of libins command for dependency spec syntax.
// @@ !! BEGIN() ---- cmpNaive.cc

const string end_mark("^__=end=__^");

struct SolveExc : exception {};

void do_game(bool is_judge);

int main(int argc, char *argv[]) {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << setprecision(20);

  bool is_judge = false;
  if (argc == 2) {
    if (strcmp(argv[1], "judge") == 0) {
      is_judge = true;
    }else if (strcmp(argv[1], "skip") == 0) {
      return 0;
    }else {
      cerr << "Unknown argument\n";
      exit(1);
    }
  }
    
  try {
    do_game(is_judge);
  }catch (const SolveExc& e) {
  }
  return 0;
}

/* 
   Copy and edit the following into the part below END
 */
/*
ll sz;

struct Judge {
  using ask_q_t = ll;
  using ask_a_t = string;
  using answer_t = ll;

  virtual void ask_q(ask_q_t x) = 0;
  virtual ask_a_t ask_a() = 0;
  virtual void answer(answer_t x) = 0;

  void wa() {
    cout << "WA\n";
    exit(1);
  }

  void ac() {
    cout << "AC\n";
    throw SolveExc();
  }
};

struct JudgeLoc : Judge {
  ll expected;
  ll asked;

  JudgeLoc() {
    // Typically, read the question for testing from stdin
    cin >> sz >> expected;
  }
  void ask_q(ask_q_t x) {
    asked = x;
  }
  ask_a_t ask_a() {
    return asked == expected ? "EQ" : asked < expected ? "LT" : "GT";
  }
  void answer(answer_t x) {
    // Always call ac() or wa().
    if (x == expected) ac();
    else wa();
  }
};

struct JudgeRem : Judge {
  JudgeRem() {
    // Read initial information, if any.
    cin >> sz;
  }
  void ask_q(ask_q_t x) {
    // Information asking.  Typically prepended by "? " and followed by endl
    cout << "? " << x << endl;
  }
  ask_a_t ask_a() {
    // Responce to the asking
    string rep; cin >> rep;
    return rep;
  }
  void answer(answer_t x) {
    // Final output.  Typically prepended by "! " and followed by endl
    cout << "! " << x << endl;
    // Need to throw SolveExc()
    throw SolveExc();
  }
};

void game(Judge&& judge) {
  ll left = 1;
  ll right = sz;
  while (true) {
    ll mid = (left + right) / 2;
    judge.ask_q(mid);
    string rep = judge.ask_a();
    if (rep == "EQ") judge.answer(mid);
    if (rep == "LT") left = mid;
    if (rep == "GT") right = mid;
  }
}

void do_game(bool is_judge) {
  if (is_judge) game(JudgeLoc());
  else          game(JudgeRem());
}
*/

// @@ !! END ---- interactive.cc

ll sz;

struct Judge {
  using ask_q_t = ll;
  using ask_a_t = string;
  using answer_t = ll;

  virtual void ask_q(ask_q_t x) = 0;
  virtual ask_a_t ask_a() = 0;
  virtual void answer(answer_t x) = 0;

  void wa() {
    cout << "WA\n";
    exit(1);
  }

  void ac() {
    cout << "AC\n";
    throw SolveExc();
  }
};

struct JudgeLoc : Judge {
  ll expected;
  ll asked;

  JudgeLoc() {
    // Typically, read the question for testing from stdin
    cin >> sz >> expected;
  }
  void ask_q(ask_q_t x) {
    asked = x;
  }
  ask_a_t ask_a() {
    return asked == expected ? "EQ" : asked < expected ? "LT" : "GT";
  }
  void answer(answer_t x) {
    // Always call ac() or wa().
    if (x == expected) ac();
    else wa();
  }
};

struct JudgeRem : Judge {
  JudgeRem() {
    // Read initial information, if any.
    cin >> sz;
  }
  void ask_q(ask_q_t x) {
    // Information asking.  Typically prepended by "? " and followed by endl
    cout << "? " << x << endl;
  }
  ask_a_t ask_a() {
    // Responce to the asking
    string rep; cin >> rep;
    return rep;
  }
  void answer(answer_t x) {
    // Final output.  Typically prepended by "! " and followed by endl
    cout << "! " << x << endl;
    // Need to throw SolveExc()
    throw SolveExc();
  }
};

void game(Judge&& judge) {
  ll left = 1;
  ll right = sz;
  while (true) {
    ll mid = (left + right) / 2;
    judge.ask_q(mid);
    string rep = judge.ask_a();
    if (rep == "EQ") judge.answer(mid);
    if (rep == "LT") left = mid;
    if (rep == "GT") right = mid;
  }
}

void do_game(bool is_judge) {
  if (is_judge) game(JudgeLoc());
  else          game(JudgeRem());
}

