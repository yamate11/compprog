#include <bits/stdc++.h>
#include <cassert>
typedef long long int ll;
using namespace std;
#define REP2(i, a, b) for (ll i = (a); i < (b); i++)
#define REP2R(i, a, b) for (ll i = (a); i >= (b); i--)
#define REP(i, b) REP2(i, 0, b)
#define ALL(coll) (coll).begin(), (coll).end()
#define SIZE(v) ((ll)((v).size()))

/*
  Refer to https://yamate11.github.io/blog/posts/2022/08-07-interactive-skelton/
  for details.

  Skelton for Interactive Problems

  (1) Edit the following member functions.
      They are for adjusting the interface.
      - ask_i()
      - answer_i()
  (2) Write logic in function solve(), using ask() and answer().
  (3) For hand debugging, compile and run.
  (4) For automated testing, do the following
  (4.1) Edit ask_judge() and answer_judge() functions.
  (4.2) Prepare input files, or prepare gen script.  
        You can define file format as long as it starts initial
        input for the interaction.

  Testing
    (*) ./cans
       This is the true program.  You can manually input data into its
       stdin.
    (**) ./cans judge < din.txt
       One-shot testing.  
    (***) cmpNaive -i -e -p './cans judge'
       cmpNaive testing.  Runs multiple times against test files
       generated by `gen' script.  A test run is regarded as a success
       if its exit code is zero.  Thus, you do not need to provide
       naive() function.
 */

// @@ !! LIM()

bool judge = false;

void solve() {

  /* Global data, including automatic testing
     Example:
     ll L, R;
     ll expected;
   */

  // ONLY FOR AUTOMATIC TESTING
  // Read additional information
  auto readinfo_judge = [&]() -> void {
    /*Example
      cin >> expected;
     */
  };

  // ONLY FOR AUTOMATIC TESTING
  // Read info given before the interactive session.
  auto readinfo = [&]() -> void {
    /* Example
       cin >> L >> R;
     */
    // The following line should not be removed.
    if (judge) readinfo_judge(); // reading additional info for automatic testing.
  };

  // ONLY FOR AUTOMATIC TESTING
  auto ask_judge = [&](ll x) -> ll {
    /* Example
    if (x < expected) return -1;
    else if (x == expected) return 0;
    else return 1;  
    */
  };

  // ONLY FOR AUTOMATIC TESTING
  // If the answer is not correct, abort.
  auto answer_judge = [&](ll x) -> void {
    /* Example
       if (x == expected) return;
       else               exit(1);
     */
  };

  // EDIT THE FOLLOWING
  auto ask_i = [&](ll x) -> ll {
    /* Example
       cout << "? " << x << endl;
       string s; cin >> s;
       if (s == "SMALL") return -1;
       else if (s == "LARGE") return 1;
       else if (s == "EQUAL") return 0;
     */
  };

  // EDIT THE FOLLOWING
  auto answer_i = [&](ll x) -> void {
    /* Example
       cout << "! " << x << endl;
    */
  };
  
  // You do not need to edit the following
  auto ask = [&](ll x) { return judge ? ask_judge(x) : ask_i(x); };
  auto answer = [&](ll x) { if (judge) answer_judge(x); else answer_i(x); };
    

  // EDIT THE FOLLOWING
  
  /* Write the logic using ask() and answer().
  Example:
  ll lo = L, hi = R;
  while (true) {
    ll mid = (lo + hi) / 2;
    ll resp = ask(mid);
    if (resp == 0) { answer(mid); return; }
    else if (resp < 0) { lo = mid; }
    else { hi = mid; }
  }
  */

}


int main(int argc, char *argv[]) {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << setprecision(20);

  if (stcmp(argv[1], "judge") == 0) { judge = true; }

  int T; cin >> T;
  REP(_t, T) { 
    solve();
  }
  return 0;
}


