#include <bits/stdc++.h>
#include <cassert>
using namespace std;
using ll = long long int;
using pll = pair<ll, ll>;
// #include <atcoder/all>
// using namespace atcoder;
#define REP(i, a, b) for (ll i = (a); i < (b); i++)
#define REPrev(i, a, b) for (ll i = (a); i >= (b); i--)
#define ALL(coll) (coll).begin(), (coll).end()
#define SIZE(v) ((ll)((v).size()))
#define REPOUT(i, a, b, exp, sep) REP(i, (a), (b)) cout << (exp) << (i + 1 == (b) ? "" : (sep)); cout << "\n"

// @@ !! LIM(segTree)

// ---- inserted function f:<< from util.cc

// declarations

template <typename T1, typename T2>
ostream& operator<< (ostream& os, const pair<T1,T2>& p);

template <typename T1, typename T2, typename T3>
ostream& operator<< (ostream& os, const tuple<T1,T2,T3>& t);

template <typename T1, typename T2, typename T3, typename T4>
ostream& operator<< (ostream& os, const tuple<T1,T2,T3,T4>& t);

template <typename T>
ostream& operator<< (ostream& os, const vector<T>& v);

template <typename T, typename C>
ostream& operator<< (ostream& os, const set<T, C>& v);

template <typename T, typename C>
ostream& operator<< (ostream& os, const unordered_set<T, C>& v);

template <typename T, typename C>
ostream& operator<< (ostream& os, const multiset<T, C>& v);

template <typename T1, typename T2, typename C>
ostream& operator<< (ostream& os, const map<T1, T2, C>& mp);

template <typename T1, typename T2, typename C>
ostream& operator<< (ostream& os, const unordered_map<T1, T2, C>& mp);

template <typename T, typename T2>
ostream& operator<< (ostream& os, const queue<T, T2>& orig);

template <typename T, typename T2>
ostream& operator<< (ostream& os, const deque<T, T2>& orig);

template <typename T, typename T2, typename T3>
ostream& operator<< (ostream& os, const priority_queue<T, T2, T3>& orig);

template <typename T>
ostream& operator<< (ostream& os, const stack<T>& st);

#if __cplusplus >= 201703L
template <typename T>
ostream& operator<< (ostream& os, const optional<T>& t);
#endif

ostream& operator<< (ostream& os, int8_t x);

// definitions

template <typename T1, typename T2>
ostream& operator<< (ostream& os, const pair<T1,T2>& p) {
  os << "(" << p.first << ", " << p.second << ")";
  return os;
}

template <typename T1, typename T2, typename T3>
ostream& operator<< (ostream& os, const tuple<T1,T2,T3>& t) {
  os << "(" << get<0>(t) << ", " << get<1>(t)
     << ", " << get<2>(t) << ")";
  return os;
}

template <typename T1, typename T2, typename T3, typename T4>
ostream& operator<< (ostream& os, const tuple<T1,T2,T3,T4>& t) {
  os << "(" << get<0>(t) << ", " << get<1>(t)
     << ", " << get<2>(t) << ", " << get<3>(t) << ")";
  return os;
}

template <typename T>
ostream& operator<< (ostream& os, const vector<T>& v) {
  os << '[';
  for (auto it = v.begin(); it != v.end(); it++) {
    if (it != v.begin()) os << ", ";
    os << *it;
  }
  os << ']';

  return os;
}

template <typename T, typename C>
ostream& operator<< (ostream& os, const set<T, C>& v) {
  os << '{';
  for (auto it = v.begin(); it != v.end(); it++) {
    if (it != v.begin()) os << ", ";
    os << *it;
  }
  os << '}';

  return os;
}

template <typename T, typename C>
ostream& operator<< (ostream& os, const unordered_set<T, C>& v) {
  os << '{';
  for (auto it = v.begin(); it != v.end(); it++) {
    if (it != v.begin()) os << ", ";
    os << *it;
  }
  os << '}';

  return os;
}

template <typename T, typename C>
ostream& operator<< (ostream& os, const multiset<T, C>& v) {
  os << '{';
  for (auto it = v.begin(); it != v.end(); it++) {
    if (it != v.begin()) os << ", ";
    os << *it;
  }
  os << '}';

  return os;
}

template <typename T1, typename T2, typename C>
ostream& operator<< (ostream& os, const map<T1, T2, C>& mp) {
  os << '[';
  for (auto it = mp.begin(); it != mp.end(); it++) {
    if (it != mp.begin()) os << ", ";
    os << it->first << ": " << it->second;
  }
  os << ']';

  return os;
}

template <typename T1, typename T2, typename C>
ostream& operator<< (ostream& os, const unordered_map<T1, T2, C>& mp) {
  os << '[';
  for (auto it = mp.begin(); it != mp.end(); it++) {
    if (it != mp.begin()) os << ", ";
    os << it->first << ": " << it->second;
  }
  os << ']';

  return os;
}

template <typename T, typename T2>
ostream& operator<< (ostream& os, const queue<T, T2>& orig) {
  queue<T, T2> que(orig);
  bool first = true;
  os << '[';
  while (!que.empty()) {
    T x = que.front(); que.pop();
    if (!first) os << ", ";
    os << x;
    first = false;
  }
  return os << ']';
}

template <typename T, typename T2>
ostream& operator<< (ostream& os, const deque<T, T2>& orig) {
  deque<T, T2> que(orig);
  bool first = true;
  os << '[';
  while (!que.empty()) {
    T x = que.front(); que.pop_front();
    if (!first) os << ", ";
    os << x;
    first = false;
  }
  return os << ']';
}

template <typename T, typename T2, typename T3>
ostream& operator<< (ostream& os, const priority_queue<T, T2, T3>& orig) {
  priority_queue<T, T2, T3> pq(orig);
  bool first = true;
  os << '[';
  while (!pq.empty()) {
    T x = pq.top(); pq.pop();
    if (!first) os << ", ";
    os << x;
    first = false;
  }
  return os << ']';
}

template <typename T>
ostream& operator<< (ostream& os, const stack<T>& st) {
  stack<T> tmp(st);
  os << '[';
  bool first = true;
  while (!tmp.empty()) {
    T& t = tmp.top();
    if (first) first = false;
    else os << ", ";
    os << t;
    tmp.pop();
  }
  os << ']';
  return os;
}

#if __cplusplus >= 201703L
template <typename T>
ostream& operator<< (ostream& os, const optional<T>& t) {
  if (t.has_value()) os << "v(" << t.value() << ")";
  else               os << "nullopt";
  return os;
}
#endif

ostream& operator<< (ostream& os, int8_t x) {
  os << (int32_t)x;
  return os;
}

// ---- end f:<<

// ---- inserted library file segTree.cc

// It seems that we should keep the size power of two,
// considering the binary search.

template <typename DAT, typename OP,
	  typename ADD_t, typename COMP_t, typename APPL_t, bool lazy> 
struct GenSegTree {
  int orig_size;     // size of initdat
  int size;	     // power of two; >= 2
  int height;        // size = 1 << height;
  vector<DAT> node;  // vector of size 2*size.
                     // 0                 : unused
                     // 1    ... size-1   : interval
                     // size ... 2*size-1 : leaf
  vector<OP> susp;   // vector of size size.
                     // suspended operation FOR CHILDREN
                     // (already applied to this node)
  DAT unit_dat;
  OP unit_op;
  ADD_t add;
  COMP_t comp;
  APPL_t appl;
    
  GenSegTree(DAT unit_dat_, OP unit_op_, ADD_t add_, COMP_t comp_, APPL_t appl_, const vector<DAT>& initdat)
    : orig_size(initdat.size()), unit_dat(unit_dat_), unit_op(unit_op_),
      add(add_), comp(comp_), appl(appl_) { _set_data(initdat); }

  void _set_data(const vector<DAT>& initdat) {
    if (initdat.size() <= 1) height = 0;
    else   height = sizeof(int) * 8 - __builtin_clz(initdat.size() - 1);
    size = 1 << height;
    node.resize(2*size, unit_dat);
    for (int i = 0; i < (int)initdat.size(); i++) node[size + i] = initdat[i];
    for (int t = size - 1; t >= 1; t--) node[t] = add(node[t<<1|0], node[t<<1|1]);
    susp.resize(size, unit_op);
  }

  void child_updated_sub(int t) {
    node[t] = appl(susp[t], add(node[t<<1|0], node[t<<1|1]));
  }

  void child_updated(int l, int r) {
    r--;
    while (l > 1) {
      l >>= 1;
      r >>= 1;
      child_updated_sub(l);
      if (l < r) child_updated_sub(r);
    }
  }

  void node_op(int i, OP f) {
    node[i] = appl(f, node[i]);
    if (i < size) susp[i] = comp(f, susp[i]);
  }

  // Note that susp[i] HAS ALREADY BEEN APPLIED TO node[i].
  // When push_one(i) is called, susp[j] is updated (for j : i's child) and it is applied to node[j].
  void push_one(int i) {
    node_op(i<<1|0, susp[i]);
    node_op(i<<1|1, susp[i]);
    susp[i] = unit_op;
  }

  void push_upto(int l, int r) {
    for (int s = height; s >= 1; s--) {
      int lz = l >> s;
      int rz = (r-1) >> s;
      push_one(lz);
      if (lz < rz) push_one(rz);
    }
  }

  DAT query(int l, int r) {
    if (l >= r) return unit_dat;
    DAT ret_l = unit_dat;
    DAT ret_r = unit_dat;
    l += size;
    r += size;
    if constexpr(lazy) push_upto(l, r);
    while (l < r) {
      if (l & 1) {
	ret_l = add(ret_l, node[l]);
	l++;
      }
      if (r & 1) {
	ret_r = add(node[r-1], ret_r);
      }
      l >>= 1;
      r >>= 1;
    }
    DAT ret = add(ret_l, ret_r);
    return ret;
  }

  template<bool xx = lazy> enable_if_t<! xx> update(int i, DAT t) {
    ll x = size + i;
    node[x] = t;
    for (x >>= 1; x >= 1; x >>= 1) node[x] = add(node[x<<1|0], node[x<<1|1]);
  }

  template<bool xx = lazy> enable_if_t<xx> update(int l, int r, OP f) {
    if (l >= r) return;
    l += size;
    r += size;
    push_upto(l, r);
    int l0 = l, r0 = r;
    while (l < r) {
      if (l & 1) {
	node_op(l, f);
	l++;
      }
      if (r & 1) {
	node_op(r-1, f);
      }
      l >>= 1;
      r >>= 1;
    }
    child_updated(l0, r0);
  }

  const DAT& operator[](int i) {
    if constexpr(lazy) push_upto(size + i, size + i + 1);
    return node[size + i];
  }

  friend ostream& operator<<(ostream& os, GenSegTree& st) {
    os << '[';
    for (int i = 0; i < st.orig_size; i++) {
      if (i > 0) os << ", ";
      os << st[i];
    }
    os << ']';
    return os;
  }

  int binsearch_r_until(const auto& check, int l) {
    // DLOGKL("in: binsearch_r_until", l);
    if (not check(unit_dat)) return l - 1;
    if (l == orig_size) return l;
    DAT val = unit_dat;
    int x = l + size;
    if constexpr(lazy) push_upto(x, x + 1);
    while (true) {
      if (x & 1) {
        DAT t = add(val, node[x]);
        if (not check(t)) break;
        val = t;
        x++;
        if (__builtin_popcountll(x) == 1) return orig_size;
      }
      x >>= 1;
      // DLOGKL("1: ", x, val);
    }
    while (x < size) {
      if constexpr(lazy) push_one(x);
      x <<= 1;
      DAT t = add(val, node[x]);
      if (check(t)) {
        x++;
        val = t;
      }
      // DLOGKL("2: ", x, val);
    }
    // DLOGKL("3: ", x - size, orig_size);
    return min(x - size, orig_size);
  }

  int binsearch_r_from(const auto& check, int l) {
    return binsearch_r_until([&](DAT x) { return not check(x); }, l) + 1;
  }

  int binsearch_l_until(const auto& check, int r) {
    if (not check(unit_dat)) return r + 1;
    if (r == 0) return 0;
    DAT val = unit_dat;
    int x = r + size;
    if (x == 2 * size) {
      if (check(node[1])) return 0;
      x = 1;
    }else {
      if constexpr(lazy) push_upto(x - 1, x);
      while (true) {
        if (x & 1) {
          x--;
          DAT t = add(node[x], val);
          if (not check(t)) break;
          val = t;
          if (__builtin_popcountll(x) == 1) return 0;
        }
        x >>= 1;
      }
    }
    while (x < size) {
      if constexpr(lazy) push_one(x);
      x = x << 1 | 1;
      DAT t = add(node[x], val);
      if (check(t)) {
        val = t;
        x--;
      }
    }
    return x + 1 - size;
  }

  int binsearch_l_from(const auto& check, int r) {
    return binsearch_l_until([&](DAT x) { return not check(x); }, r) - 1;
  }

};

template<typename DAT, typename OP>
auto make_seg_tree_lazy(DAT unit_dat, OP unit_op, auto add, auto comp, auto appl, const vector<DAT>& initdat) {
// -> GenSegTree<DAT, OP, decltype(add), decltype(comp), decltype(appl), true> {
  using ret_t = GenSegTree<DAT, OP, decltype(add), decltype(comp), decltype(appl), true>;
  return ret_t(unit_dat, unit_op, add, comp, appl, initdat);
}

template<typename DAT>
auto make_seg_tree(DAT unit_dat, auto add, const vector<DAT>& initdat) {
  //  -> GenSegTree<DAT, void *, decltype(add), decltype(comp), decltype(appl), true> {
  auto dummy_comp = [](void* x, void* y) -> void* { return nullptr; };
  auto dummy_appl = [](void* f, DAT x) -> DAT { return DAT(); };
  using ret_t = GenSegTree<DAT, void*, decltype(add), decltype(dummy_comp), decltype(dummy_appl), false>;
  return ret_t(unit_dat, nullptr, add, dummy_comp, dummy_appl, initdat);
}


// ---- end segTree.cc

// @@ !! LIM -- end mark --



struct Tree {

  int numNodes;
  int root;
  int numEdges = 0;
  vector<vector<int>> _nbr;
      // if (u, v) is an edge, then _nbr[u] has v and _nbr[v] has u.
  vector<int> _parent;
  vector<vector<int>> _children;
  vector<int> _depth;
  vector<int> _stsize;
  bool _use_edge_idx = false;
  unordered_map<int, map<int, int>> _node2edgeIdx;
  vector<pair<int, int>> _edges;
  vector<int> _preord;
  vector<int> _preord_rev;
  vector<int> _postord;
  vector<int> _postord_rev;
  bool _use_hl_decomp = false;
  vector<int> _heavy_top; // the top node of the heavy edges
  vector<int> _heavy_bot; // the bottom node of the heavy edges
  vector<vector<int>> pPnt;   
          // pPnt[0][n] == parent of n (or root if n is root)
          // pPnt[t][n] == parent^{2^t}[n]

  Tree(int numNodes_, int root_ = 0) : numNodes(numNodes_), root(root_), _nbr(numNodes_) {}

  // Implementation note:
  // Adding Tree(int, const vector<pair<int, int>>, int) is not a good idea.  If it were added,
  // Tree tr(n, x); would fail when x is long long.  You need to write Tree tr(n, (int)x), then.

  int add_edge(int x, int y) {
    if (numEdges >= numNodes - 1) throw runtime_error("Too many edges added.");
    _nbr[x].push_back(y);
    _nbr[y].push_back(x);
    if (_use_edge_idx) {
      _node2edgeIdx[x][y] = _node2edgeIdx[y][x] = numEdges;
      _edges.emplace_back(x, y);
    }
    if (++numEdges == numNodes - 1) _set_parent_child();
    return numEdges - 1;
  }

  void _set_parent_child() {
    if (numNodes != numEdges + 1) throw range_error("numNodes and numEdges");
    _parent.resize(numNodes);
    _children.resize(numNodes);
    auto dfs = [&](auto rF, int nd, int pt, int d) -> void {
      _parent[nd] = pt;
      for (int c : _nbr[nd]) if (c != pt) {
          _children[nd].push_back(c);
          rF(rF, c, nd, d + 1);
        }
    };
    dfs(dfs, root, -1, 0);
  }

  // parent(root) == -1
  int parent(int x) { return _parent[x]; }
  int child(int x, int i) { return _children[x][i]; }
  int num_children(int x) { return _children[x].size(); }
  const vector<int>& children(int x) { return _children[x]; }

  int stsize(int x) {
    if (_stsize.empty()) {
      _stsize.resize(numNodes, 0LL);
      auto dfs = [&](auto rF, int nd) -> void {
        _stsize[nd] = 1;
        for (int c : _children[nd]) {
          rF(rF, c);
          _stsize[nd] += _stsize[c];
        }
      };
      dfs(dfs, 0);
    }
    return _stsize[x];
  }

  int depth(int x) {
    if (_depth.empty()) {
      auto dfs = [&](auto rF, int nd, int dp) -> void {
        _depth[nd] = dp;
        for (int c : _children[nd]) rF(rF, c, dp + 1);
      };
      dfs(dfs, 0, 0);
    }
    return _depth[x];
  }

  void preparePPnt() {
    if (not pPnt.empty()) return;
    vector<int> vec_parent(numNodes);
    for (int i = 0; i < numNodes; i++) vec_parent[i] = i == root ? i : _parent[i];
    pPnt.push_back(move(vec_parent));
    for (int t = 0; true; t++) {
      bool done = true;
      vector<int> vec(numNodes);
      for (int n = 0; n < numNodes; n++) {
	int m = pPnt[t][n];
	vec[n] = pPnt[t][m];
	if (vec[n] != m) done = false;
      }
      pPnt.push_back(move(vec));
      if (done) break;
    }
  }

  // Lowest Common Ancestor
  int lca(int x, int y) {
    preparePPnt();
    if (depth(x) > depth(y)) swap(x, y);
    int dep = depth(x);
    int yy = ancestorDep(y, dep);
    if (x == yy) return x;
    int t = 0;
    for (int q = 1; q < dep; q *= 2) t++;
    for ( ; t >= 0; t--) {
      if (pPnt[t][x] != pPnt[t][yy]) {
	x = pPnt[t][x];
	yy = pPnt[t][yy];
      }
    }
    return parent(x);
  }

  // the path between two nodes (list of nodes, including x and y)
  vector<int> nnpath(int x, int y) {
    vector<int> ret;
    int c = lca(x, y);
    for ( ; x != c; x = parent(x)) ret.push_back(x);
    ret.push_back(c);
    int len = (int)ret.size();
    for ( ; y != c; y = parent(y)) ret.push_back(y);
    reverse(ret.begin() + len, ret.end());
    return ret;
  }

  // the ancestor of n whose depth is dep
  int ancestorDep(int x, int dep) {
    preparePPnt();
    int diff = depth(x) - dep;
    if (diff < 0) throw range_error("ancestorDep");
    for (int t = 0; diff >> t; t++) if (diff >> t & 1) x = pPnt[t][x];
    return x;
  }

  void useEdgeIdx(bool flag = true) { _use_edge_idx = flag; }

  int edgeIdx(int x, int y) {
    if (_node2edgeIdx.empty()) throw runtime_error("edgeIdx: FATAL: you must call Tree.useEdgeIdx() just after creating Tree.");
    auto itx = _node2edgeIdx.find(x);
    if (itx == _node2edgeIdx.end()) return -1;
    auto ity = itx->second.find(y);
    if (ity == itx->second.end()) return -1;
    return ity->second;
  }

  pair<int, int> nodesOfEdge(int e) {
    if (_edges.empty()) throw  runtime_error("nodesOfEdge: FATAL: you must call Tree.useEdgeIdx() just after creating Tree.");
    return _edges[e];
  }

  void _make_dfs_order() {
    if (not _preord.empty()) return;
    _preord.resize(numNodes);
    _preord_rev.resize(numNodes);
    _postord.resize(numNodes);
    _postord_rev.resize(numNodes);
    int preidx = 0;
    int postidx = 0;
    if (_use_hl_decomp) _heavy_top.resize(numNodes);
    auto dfs = [&](auto rF, int nd, int ht) -> void {
      _preord[nd] = preidx;
      _preord_rev[preidx] = nd;
      preidx++;
      int hc = -1;
      if (_use_hl_decomp) {
        _heavy_top[nd] = ht;
        int vmax = 0;
        for (int c : _children[nd]) {
          if (stsize(c) > vmax) {
            vmax = stsize(c);
            hc = c;
          }
        }
        if (hc >= 0) {
          rF(rF, hc, ht);
          _heavy_bot[nd] = _heavy_bot[hc];
        }else {
          _heavy_bot[nd] = nd;
        }
      }
      for (int c : _children[nd]) if (c != hc) rF(rF, c, c);
      _postord[nd] = postidx;
      _postord_rev[postidx] = nd;
      postidx++;
      return ret;
    };
    dfs(dfs, 0, 0);
  }

  int node2preidx(int nd)  { _make_dfs_order(); return _preord[nd]; }
  int preidx2node(int i)   { _make_dfs_order(); return _preord_rev[i]; }
  int node2postidx(int nd) { _make_dfs_order(); return _postord[nd]; }
  int postidx2node(int i)  { _make_dfs_order(); return _postord_rev[i]; }

  void _prepareHL() {
    if (not _heavy_top.empty()) return;
    if (not _preord.empty()) throw runtime_error("_prepareHL: FATAL: Vector _preord is inconsistent.  Call Tree.useHLDecomp() just after creating Tree.");
    _use_hl_decomp = true;
    _make_dfs_order();
  }

  int heavyTop(int nd) { _prepareHL(); return _heavy_top[nd]; }
  int heavyChild(int nd) {
    _prepareHL();
    int i = _preord[nd];
    if (i == numNodes - 1) return -1;
    ll c = _preord_rev[i + 1];
    if (parent(c) == nd) return c;
    return -1;
  }
  bool isEdgeHeavy(int nd1, int nd2) {
    if      (parent(nd1) == nd2) return _preord[nd1] == _preord[nd2] + 1; 
    else if (parent(nd2) == nd1) return _preord[nd2] == _preord[nd1] + 1;
    else throw runtime_error("isEdgeHeavy: FATAL: No edge between nd1 and nd2.");
  }

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"    
  tuple<int, int, int, int, int> diameter() {
    if (numNodes == 1) return {0, 0, 0, 0, 0};
    if (numNodes == 2) return {1, 0, 1, 0, 1};
    if (_depth.empty()) depth(0);
    int nd0 = max_element(_depth.begin(), _depth.end()) - _depth.begin();
    int nd1 = -1, ct0 = -1, ct1 = -1;
    int diam = 0;
    auto dfs2 = [&](auto rF, int nd, int dp, int pt) -> bool {
      bool ret = false;
      ll numChildren = 0;
      for (ll cld : _nbr[nd]) {
        if (cld == pt) continue;
        numChildren++;
        bool bbb = rF(rF, cld, dp + 1, nd);
        ret = ret || bbb;
      }
      if (numChildren > 0) {
        if (ret) {
          if (diam % 2 == 0) {
            if (dp == diam / 2) ct0 = ct1 = nd;
          }else {
            if (dp == diam / 2) ct0 = nd;
            else if (dp == diam / 2 + 1) ct1 = nd;
          }
        }
      }else {
        if (dp > diam) {
          diam = dp;
          nd1 = nd;
          ret = true;
        }
      }
      return ret;
    };
    dfs2(dfs2, nd0, 0, -1);
    return {diam, nd0, nd1, ct0, ct1};
  }
#pragma GCC diagnostic pop

  void change_root(int newRoot) {
    pPnt.resize(0);
    _depth.resize(0);
    _parent.resize(0);
    _children.resize(0);
    _set_parent_child();
    root = newRoot;
  }

};

template <typename T>
vector<T> reroot(Tree& tree, const T& unit, auto add, auto mod) {
  vector<T> result(tree.numNodes);
  vector<T> sum(tree.numNodes);
  vector<vector<T>> sum_excl(tree.numNodes);
  
  auto dfs1 = [&](const auto& recF, int n) -> void {
    const auto& cld = tree.children(n);
    int k = cld.size();
    vector<T> right(k+1), m(k+1);
    T g = right[k] = unit;
    for (int i = k-1; i >= 0; i--) {
      int c = cld[i];
      recF(recF, c);
      m[i] = mod(sum[c], n, c);
      right[i] = g = add(m[i], g);
    }
    sum[n] = g;
    T gp = unit;
    sum_excl[n].resize(k);
    for (int i = 0; i < k; i++) {
      sum_excl[n][i] = add(gp, right[i+1]);
      gp = add(gp, m[i]);
    }
  };
  dfs1(dfs1, tree.root);

  auto dfs2 = [&](const auto& recF, int n, T t) -> void {
    result[n] = add(sum[n], t);
    const auto& cld = tree.children(n);
    int k = cld.size();
    for (int i = 0; i < k; i++) {
      int c = cld[i];
      recF(recF, c, mod(add(sum_excl[n][i], t), c, n));
    }
  };
  dfs2(dfs2, tree.root, unit);
  
  return result;
}

int main(/* int argc, char *argv[] */) {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << setprecision(20);

  ll big = 1e18;
  ll N; cin >> N;
  Tree tr(N);
  tr.UseEdgeIdx();
  tr.UseHLDecomp();
  auto D = vector(N - 1, 0LL);
  REP(i, 0, N - 1) {
    ll u, v; cin >> u >> v; u--; v--;
    ll e = tr.add_edge(u, v);
    cin >> D[e];
  }
  auto distTop = vector(N, 0LL);
  REP(i, 0, N) {
    ll nd = preidx2node(i);
    ll p = tr.parent(nd);
    if (heavyTop(nd) != nd) distTop[nd] = distTop[p] + D[tr.edgeIdx(nd, p)];
  }
  auto heavyBot = vector(N, 0LL);
  REP(i, 0, N) 

  auto mymin = [&](ll a, ll b) -> ll { return min(a, b); };
  auto st1 = make_seg_tree<ll>(big, mymin, vector<ll>(N, big));
  auto st2 = make_seg_tree<ll>(big, mymin, vector<ll>(N, big));
  auto down = vector(N, big);

  auto make_supermarket = [&](ll v) -> void {
    ll newval = 0;
    while (true) {
      if (down[v] <= newval) break;
      down[v] = newval;
      st1[tr.node2preidx(v)] = down[v] + distTop[v];
      st2[tr.node2preidx(v)] = down[v] - distTop[v];
      ll t = tr.heavyTop(v);
      ll vv = tr.parent(t);
      if (vv < 0) break;
      newval = down[v] + distTop[v] + D[tr.edgeIdx(t, vv)];
      v = vv;
    }
  };

  auto report = [&](ll v) -> ll {
    
  };

  ll K; cin >> K;
  REP(i, 0, K) {
    ll v; cin >> v; v--;
    make_supermarket(v);
  }
  ll Q; cin >> Q;
  REP(_q, 0, Q) {
    ll p, v; cin >> p >> v; v--;
    if (p == 1) make_supermarket(v);
    else if (p == 2) cout << report(v) << "\n";
    else assert(0);
  }


  return 0;
}

