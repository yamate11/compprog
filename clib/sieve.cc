#include <bits/stdc++.h>
#include <cassert>
typedef long long int ll;
using namespace std;

/*
  sieve.cc -- prime numbers and factorization

  vector<int> primes = sieve(n);
    // Returns the list of prime numbers upto n.
    // Performance:
    //   Size: upto(1e8).size() ... 5.7e6,  upto(1e9).size() ... 5.1e7
    //   Speed: upto(1e8) ... 0.7sec,   upto(1e9) ... 9.2sec

  vector<int> divSieve = divisorSieve(n);
    // Returns the list of the least prime divisors upto n.
    // E.g. divSieve[2] == 2, divSieve[15] == 3, divSieve[77] == 7, etc.

  vector<pair<ll, int>>  pr = prfac(m);
  vector<pair<ll, int>>  pr = prfac(m, primes);
  vector<pair<int, int>> pr = prfacDivSieve(m, divSieve);
    // Returns the prime factorization results.
    // The latter is naturally faster.
    // primes should contain prime numbers at least up to sqrt(m)
    // divSieve should contain divisors upto m.

  vector<ll>  divs = getDivisors(m);
  vector<ll>  divs = getDivisors(m, primes);
  vector<ll>  divs = getDivisorsDivSieve(m, divSieve);
    // Returns a list of all divisors of m.
    // NOTE: the results are *** NOT SORTED ***.
    // primes should contain prime numbers at least up to sqrt(m)
    // divSieve should contain divisors upto m.

*/

//////////////////////////////////////////////////////////////////////
// See help of libins command for dependency spec syntax.
// @@ !! BEGIN(f:itrange) ---- sieve.cc

// sieve(upto) returns the list of prime numbers up to upto.
//   Size: upto(1e8).size() ... 5.7e6,  upto(1e9).size() ... 5.1e7
//   Performance: upto(1e8) ... 0.7sec,   upto(1e9) ... 9.2sec
vector<int> sieve(int upto) {
  vector<int> res;
  vector<bool> tbl(upto+1);
  ll lim = (int)(sqrt((double)upto)) + 1;
  for (int x = 2; x <= upto; x++) {
    if (tbl[x]) continue;
    res.push_back(x);
    if (x <= lim) {
      for (int y = x * x; y <= upto; y += x) tbl[y] = true;
    }
  }
  return res;
}

vector<int> divisorSieve(int upto) {
  vector<int> tbl(upto+1);
  iota(tbl.begin(), tbl.end(), 0);
  ll lim = (int)(sqrt((double)upto)) + 1;
  for (int x = 2; x <= lim; x++) {
    if (tbl[x] < x) continue;
    for (int y = x * x; y <= upto; y += x) if (tbl[y] == y) tbl[y] = x;
  }
  return tbl;
}

/*
  Prime Factorization
    Two versions:
      - prfac(n)
      - prfac(n, primes)
            primes should contain prime numbers at least up to sqrt(n)
 */

vector<pair<ll, int>> _prfac_sub(ll n, const auto& it_beg, const auto& it_end) {
  vector<pair<ll, int>> res;
  ll x = n;
  for (auto it = it_beg; it != it_end and *it * *it <= x; it++) {
    ll p = *it;
    int r = 0;
    while (x % p == 0) {
      x /= p;
      r++;
    }
    if (r > 0) res.push_back(make_pair(p, r));
  }
  if (x > 1) res.push_back(make_pair(x, 1));
  return res;
}

vector<pair<ll, int>> prfac(ll n) {
  ItRange itr(2, n + 1);
  return _prfac_sub(n, itr.begin(), itr.end());
}
vector<pair<ll, int>> prfac(ll n, const vector<int>& primes) {
  return _prfac_sub(n, primes.begin(), primes.end());
}

vector<pair<int, int>> prfacDivSieve(int n, const vector<int>& divSieve) {
  vector<pair<int, int>> ret;
  int p = -1;
  int r = 0;
  while (n > 1) {
    int q = divSieve[n];
    if (p == q) {
      r++;
    }else {
      if (p > 0) ret.emplace_back(p, r);
      p = q;
      r = 1;
    }
    n /= p;
  }
  if (p > 0) ret.emplace_back(p, r);
  return ret;
}

/*
    List of divisors
      - getDivisors(n)
      - getDivisors(n, primes)
            primes should contain prime numbers at least up to sqrt(n)
    Note: the results are NOT sorted
 */

// _gdsub ... aux function used in getDivisors()
vector<ll> _gdsub(int i, auto fs) {
  if (i == (int)fs.size()) { return vector<ll>({1}); }
  auto part = _gdsub(i+1, fs);
  auto [p, r] = fs[i];
  ll pp = p;    // pp = p^m, for m \in [1, r]
  int partOrigLen = part.size();
  for (int m = 1; m <= r; m++) {
    for (int j = 0; j < partOrigLen; j++) part.push_back(pp * part[j]);
    pp *= p;
  }
  return part;
}

vector<ll> getDivisors(ll n) { return _gdsub(0, prfac(n)); }
vector<ll> getDivisors(ll n, const vector<int>& primes) { return _gdsub(0, prfac(n, primes)); }
vector<ll> getDivisorsDivSieve(ll n, const vector<int>& divSieve) { return _gdsub(0, prfacDivSieve(n, divSieve)); }

// @@ !! END ---- sieve.cc
