#!/usr/bin/env python3

import os, sys, re

srcpath = './cans.cc'

def eout(*msg):
    print(*msg, file=sys.stderr, flush=True)

def check_cans_cc():
    if os.path.exists(srcpath):
        x = ask(f'{srcpath} exists.  OK to remove (y/n)? ')
        if not x.upper().startswith('Y'):
            eout('Abort.')
            sys.exit(1)
        os.unlink(srcpath)

def ask(prompt, default=None):
    print(prompt, end='', flush=True, file=sys.stderr)
    if default:
        print(f'[{default}] ', end='', flush=True, file=sys.stderr)
    x = input()
    x.strip()
    if x == '' and default:
        return default
    return x

def main():

    check_cans_cc()
    t_i = ask('''Type of Interaction.  Select 1 or 2.
  1. ASK FIRST
      You first ask information to the judge program, 
      then the judge returns the answer.  In this case, type "1".
  2. ASKED FIRST
      The judge first asks you with some info,
      then you responds to the judge.  In this case, type "2".
>>>> ''', '1');
    ask_first_p = not t_i.strip().startswith('2')
    ask_type = ask('''Type of your output for interaction, with variable names,
as in the function declaration
If your output for interaction consists of three long long, then specify
for example:
        ll x, ll y, ll z
or 
        long long a1, long long a2, long long a3
If your output consists of a single string, then specify e.g.:
        string s
Note that even if you need to ask, say "? 10 20", you do not need to 
specify the question mark here.  For this, simply respond with
        ll left, ll right
>>>> ''', 'll x');
    resp_type = ask('''Type of judge's output for interaction.
Specify only one type, because this will be the return type of a function.
If judge's output consists of two long long, then specify:
        pair<ll, ll>
If judge's output is a string, then specify:
        string
If judge's output is either "YES" or "NO", you may want to specify:
bool, rather than string.  Then, you could specify ask() something like:
        bool ask(...) { string s; cin >> s; return s == "YES"; }
>>>> ''', 'll');
    fin_ans = ask('''Type of your final answer with variable names.
Specify the types separated by commas.  If none is needed, specify "void",
(you need to call answer() to throw SolveExc() even in such cases.)
>>>> ''', 'll x')    
    if fin_ans == 'void':
        fin_ans = ''
    print('''File cans.cc has been created.  Open and read the description
in the beginning of the file.''')

    template = '''#include <bits/stdc++.h>
#include <cassert>
typedef long long int ll;
using namespace std;

/*
  Skelton for Interactive Problems

  (1) Edit the following member functions in JudgeRem class 
      They are for adjusting the interface.
      - constructor
      - ask()   (or ask_q() and ask_a())
      - answer()
  (2) Write function game().  This is for writing your algorithm.
  (3) For hand debugging, compile and run.
  (4) For automated testing, do the following
  (4.1) Set the value of macro JUDGE_LOC to 1.
  (4.2) Edit JudgeLoc struct

  Testing
    (*) ./cans
       This is the true program.  You can manually input data into its
       stdin.
    (**) ./cans judge < din.txt
       One-shot testing.  The format of din.txt is not defined by the
       writer of the question.  You can freely set the spec for the input
       file so that JudgeLoc() can read the input.
    (***) cmpNaive -i -e -p './cans judge'
       cmpNaive testing.  Runs multiple times against test files
       generated by `gen' script.  A test run is regarded as a success
       if its exit code is zero.
 */

// @@ !! LIM()

// When you debug with JudgeLoc class, the value should be 1
#define JUDGE_LOC 0
// #define JUDGE_LOC 1

const string end_mark("^__=end=__^");

struct SolveExc : exception {};

void do_game(bool is_judge);

int main(int argc, char *argv[]) {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << setprecision(20);

  bool is_judge = false;
  if (argc == 2) {
    if (strcmp(argv[1], "judge") == 0) {
      is_judge = true;
    }else if (strcmp(argv[1], "skip") == 0) {
      return 0;
    }else {
      cerr << "Unknown argument" << endl;
      exit(1);
    }
  }
    
  try {
    do_game(is_judge);
  }catch (const SolveExc& e) {
  }
  return 0;
}

/* External variables, typically for values given as initial input. */
// ll N;

struct Judge {
####( INSERT 0 )####

  // Call ac() in JudgeLoc when the answer is correct.
  void ac() {
    cout << "AC" << endl;
    throw SolveExc();
  }

  // Call wa() in JudgeLoc when the answer is not correct.
  void wa() {
    cout << "WA" << endl;
    exit(1);
  }
};

#if JUDGE_LOC
// This is a class for local testing.
struct JudgeLoc : Judge {
  ll expected;    // Typically, expected answer is read in the beginning
                  // from the question-specifying file.

  JudgeLoc() {
    // Typically, read the question for testing from stdin
    /*
    cin >> N >> expected;
    */
  }

####( INSERT 1 )####

  // Always call ac() or wa().
####( INSERT 3 )####
    /*
    if (x == expected) ac();
    else wa();
    */
  }
};
#endif // JUDGE_LOC

// The class that implements interfaces to the external judge program.
struct JudgeRem : Judge {

  // Read initial information in the constructor.  
  // Typically you need to read a parameter
  // such as the size of the question.  You may want to define a global
  // variable, such as N, just the above of line of "struct Judge{".
  JudgeRem() {
    /*
    cin >> N;
    */
  }

####( INSERT 2 )####

  // Final output.  Typically prepended by "! " and followed by endl
  // You need to throw SolveExc() at the end of the function.
####( INSERT 3 )####
    /*
    cout << "! " << x << endl;
    */
    throw SolveExc();
  }

};

// You write your algorithm using judge.ask()
// (or judge.ask_a() and judge.ask_q()).
// Note that you need to call judge.answer() to correctly terminate
// the program.
void game(Judge&& judge) {
  /*
  // example for Guessing Number Game
  ll left = 1;
  ll right = sz;
  while (true) {
    ll mid = (left + right) / 2;
    ll reply = judge.ask(mid);
    if (reply == 0) judge.answer(mid);
    if (reply == -1) right = mid - 1;
    if (reply == 1)  left  = mid + 1;
  }
  */
}

// You should not edit this function.
void do_game(bool is_judge) {
#if JUDGE_LOC
  if (is_judge) game(JudgeLoc());
  else          game(JudgeRem());
#else
  game(JudgeRem());
#endif
}
'''

    insert = [''] * 4

    if ask_first_p:
        insert[0] = f'''  virtual {resp_type} ask({ask_type}) = 0;
  virtual void answer({fin_ans}) = 0;
'''
        insert[1] = f'''  // Returns the answer for a query x.
  {resp_type} ask({ask_type}) {{
    // An example for Guessing Number Game.
    /*
    if (x < expected)      return 1;
    else if (x > expected) return -1;
    else                   return 0;
    return ask_a_t();
    */
  }}
'''
        insert[2] = f'''  // Asks for and receives information
  {resp_type} ask({ask_type}) {{
  }}
  /*
  An example:
    bool ask(ll x, ll y) {{
      cout << "? " << x << " " << y << endl;
      string ret; cin >> ret;
      return ret == "YES";
    }}
  */
'''
    else:
        insert[0] = f'''  virtual void ask_q({ask_type}) = 0;
  virtual {resp_type} ask_a() = 0;
  virtual void answer({fin_ans}) = 0;
'''        
        insert[1] = f'''  // Receives a reply from the user program 
  void ask_q({ask_type}) {{
    // An example for Stone Taking Game (1-3)
    /*
    if (x <= 0 || 3 <= x || sz < x) wa();
    sz -= x;
    */
  }}
  // Send a request for the user program to process data
  {resp_type} ask_a() {{
    // An example for Stone Taking Game (1-3)
    /*
    ll e = rand() % max(sz, 3) + 1;
    sz -= e;
    return e;
    */
  }}
'''
        insert[2] = f'''  // Reads a request from the external judge program.
  {resp_type} ask_a() {{
    /*
    ask_a_t rep; cin >> rep;
    return rep;
    */
  }}
  // Writes a reply to the external judge program.
  void ask_q({ask_type}) {{
    /*
    cout << "? " << x << endl;
    */
  }}
'''
    insert[3] = f'  void answer({fin_ans}) {{\n'

    cont = ''
    for line in template.split('\n'):
        mo = re.match(r'^####\( INSERT (\d+)', line)
        if mo:
            cont += insert[int(mo[1])]
        else:
            cont += line
            cont += '\n'

    with open(srcpath, 'w') as wfp:
        print(cont, file=wfp)
    

main()
