#!/usr/bin/env python3

import os, sys, re

srcpath = './cans.cc'

def eout(*msg):
    print(*msg, file=sys.stderr, flush=True)

def check_cans_cc():
    if os.path.exists(srcpath):
        x = ask(f'{srcpath} exists.  OK to remove (y/n)? ')
        if not x.upper().startswith('Y'):
            eout('Abort.')
            sys.exit(1)
        os.unlink(srcpath)

def ask(prompt, default=None):
    print(prompt, end='', flush=True, file=sys.stderr)
    if default:
        print(f'[{default}] ', end='', flush=True, file=sys.stderr)
    x = input()
    x.strip()
    if x == '' and default:
        return default
    return x

def main():

    check_cans_cc()
    ask_type = ask('''Type of your output for interaction, with variable names,
as in the function declaration
If your output for interaction consists of three long long, then specify
for example:
        ll x, ll y, ll z
or 
        long long a1, long long a2, long long a3
If your output consists of a single string, then specify e.g.:
        string s
Note that even if you need to ask, say "? 10 20", you do not need to 
specify the question mark here.  For this, simply respond with
        ll left, ll right
>>>> ''', 'll x');
    resp_type = ask('''Type of judge's output for interaction.
Specify only one type, because this will be the return type of a function.
If judge's output consists of two long long, then specify:
        pair<ll, ll>
If judge's output is a string, then specify:
        string
If judge's output is either "YES" or "NO", you may want to specify:
bool, rather than string.  Then, you could specify ask() something like:
        bool ask(...) { string s; cin >> s; return s == "YES"; }
>>>> ''', 'll');
    fin_ans = ask('''Type of your final answer with variable names.
Specify the types separated by commas.  If none is needed, specify "void",
(you need to call answer() to throw SolveExc() even in such cases.)
>>>> ''', 'll x')    
    if fin_ans == 'void':
        fin_ans = ''
    mult_q = ask('''Multiple-question style?  Select Y or N.
>>>> ''', 'N')
    mult_q_str = 'int T; cin >> T;\n  for (int _t = 0; _t < T; _t++) {' if mult_q[0] in "Yy" else '{'

    print('''File cans.cc has been created.  Open and read the description
in the beginning of the file.''')

    template = '''#include <bits/stdc++.h>
#include <cassert>
typedef long long int ll;
using namespace std;
#define REP2(i, a, b) for (ll i = (a); i < (b); i++)
#define REP2R(i, a, b) for (ll i = (a); i >= (b); i--)
#define REP(i, b) REP2(i, 0, b)
#define ALL(coll) (coll).begin(), (coll).end()
#define SIZE(v) ((ll)((v).size()))

/*
  Refer to https://yamate11.github.io/blog/posts/2022/08-07-interactive-skelton/
  for details.

  Skelton for Interactive Problems

  (1) Edit the following member functions.
      They are for adjusting the interface.
      - ask_i()
      - answer_i()
  (2) Write logic in function solve(), using ask() and answer().
  (3) For hand debugging, compile and run.
  (4) For automated testing, do the following
  (4.1) Edit ask_judge() and answer_judge() functions.
  (4.2) Prepare input files, or prepare gen script.  
        You can define file format as long as it starts initial
        input for the interaction.

  Testing
    (*) ./cans
       This is the true program.  You can manually input data into its
       stdin.
    (**) ./cans judge < din.txt
       One-shot testing.  
    (***) cmpNaive -i -e -p './cans judge'
       cmpNaive testing.  Runs multiple times against test files
       generated by `gen' script.  A test run is regarded as a success
       if its exit code is zero.  Thus, you do not need to provide
       naive() function.
 */

// @@ !! LIM()

bool judge = false;

void solve() {

  // EDIT APPROPRIATELY
  /* Global data, including automatic testing
     Example:
     ll L, R;         // global data
     ll expected;     // for automatic testing
   */

  // ONLY FOR AUTOMATIC TESTING
  // Read additional information
  auto readinfo_judge = [&]() -> void {
    /*Example
      cin >> expected;
     */
  };

  // EDIT APPROPRIATELY
  // Read info given before the interactive session.
  auto readinfo = [&]() -> void {
    /* Example
       cin >> L >> R;
     */
    // The following line should not be removed.
    if (judge) readinfo_judge(); // reading additional info for automatic testing.
  };

  // ONLY FOR AUTOMATIC TESTING
  auto ask_judge = [&]({{ ask_type }}) -> {{ resp_type }} {
    /* Example
    if (x < expected) return -1;
    else if (x == expected) return 0;
    else return 1;  
    */
    return {{ resp_type }}();  // This is a dummy for avoiding compilation errors.
  };

  // ONLY FOR AUTOMATIC TESTING
  // If the answer is not correct, abort.
  auto answer_judge = [&]({{ fin_ans }}) -> void {
    /* Example
       if (x == expected) return;
       else               exit(1);
     */
  };

  // EDIT APPROPRIATELY
  auto ask_i = [&]({{ ask_type }}) -> {{ resp_type }} {
    /* Example
       cout << "? " << x << endl;
       string s; cin >> s;
       if (s == "SMALL") return -1;
       else if (s == "LARGE") return 1;
       else if (s == "EQUAL") return 0;
     */
  };

  // EDIT APPROPRIATELY
  auto answer_i = [&]({{ fin_ans }}) -> void {
    /* Example
       cout << "! " << x << endl;
    */
  };
  
  // You do not need to edit the following
  auto ask = [&]({{ ask_type }}) -> {{ resp_type }} { return judge ? ask_judge(x) : ask_i(x); };
  auto answer = [&]({{ fin_ans }}) { if (judge) answer_judge(x); else answer_i(x); };

  readinfo();

  // EDIT APPROPRIATELY
  /* Write the logic using ask() and answer().
  Example:
  ll lo = L, hi = R;
  while (true) {
    ll mid = (lo + hi) / 2;
    ll resp = ask(mid);
    if (resp == 0) { answer(mid); return; }
    else if (resp < 0) { lo = mid; }
    else { hi = mid; }
  }
  */

}


int main(int argc, char *argv[]) {
  ios_base::sync_with_stdio(false);
  cin.tie(nullptr);
  cout << setprecision(20);

  if (argc >= 2 and strcmp(argv[1], "judge") == 0) { judge = true; }

  {{ mult_q_str }}
    solve();
  }
  return 0;
}
'''

    with open(srcpath, 'w') as wfp:
        for line in template.split('\n'):
            line = line.replace('{{ ask_type }}', ask_type);
            line = line.replace('{{ resp_type }}', resp_type);
            line = line.replace('{{ fin_ans }}', fin_ans);
            line = line.replace('{{ mult_q_str }}', mult_q_str);
            print(line, file=wfp)
    

main()
