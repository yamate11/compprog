#!/usr/bin/env python3

import sys, os, argparse, re, json
from util import topDir

magic = '@@ !!'
markpat = magic + r'\s*LIM(?:\s*\((.*)\))?';
depCache = f'{topDir}/clib/.lib_depend'
dcAtime = 0

# dictionary for dependency.
#   If 'lib1' is in dep['lib2'], then lib1.cc is needed for
#   (i.e., must be included ealier than) lib2.cc.
#   If 'f:func' is in dep['lib3'], then function func is needed
#   for lib3.cc.
dep = {}
# definition information.
#   If defAt['func'] is lib, then func is defined in lib.cc.
#   Note that prefix 'f:' does NOT appear in keys of defAt.
defAt = {}

class MyExc(Exception):
    pass
class StaleExc(Exception):
    pass

def abort(msg):
    print("libins: Fatal: " + msg, file=sys.stderr)
    sys.exit(1)

def log(msg):
    print(msg, file=sys.stderr)

def buildInfo():
    global dep, defAt, dcAtime
    dep = {}
    defAt = {}
    clibdir = f'{topDir}/clib'
    for fn in os.listdir(clibdir):
        if fn[-3:] != '.cc': continue
        libname = fn[:-3]
        path = f'{clibdir}/{fn}'
        dep[libname] = []
        with open(path, 'r') as fp:
            for line in fp:
                mo = re.search(magic + r'\s*BEGIN\s*\((.*)\)', line)
                if mo:
                    dep[libname] = mo[1].split()
                pat = r'\s*FUNC\s+BEGIN\s+(\S+)(?:\s*\((.*)\))?'
                mo = re.search(magic + pat, line)
                if mo:
                    funcname = mo[1]
                    if funcname in defAt:
                        p1 = defAt[funcname]
                        abort(f'Function {funcname} is defined twice: '
                              f'{defAt[funcname]} and {libname}');
                    defAt[funcname] = libname
                    if mo[2]:
                        dep[funcname] = mo[2].split()
    with open(depCache, 'w') as fp:
        json.dump({'dep': dep, 'defAt': defAt}, fp)
    dcAtime = None
        
def readCachedDep():
    global dep, defAt, dcAtime
    if not os.path.exists(depCache):
        buildInfo()
        return
    with open(depCache, 'r') as fp:
        info = json.load(fp)
    dep = info['dep']
    defAt = info['defAt']
    dcAtime = os.stat(depCache).st_atime


def depSort(libs):

    # Add all dependent files into res
    res = []
    def phase1(lib, pends):
        if lib in res: return
        if lib in defAt and defAt[lib] in res: return
        if lib in dep:
            for item in dep[lib]:
                if item in pends:
                    if dcAtime is None:
                        abort(f'Dependency loop: {pends + [lib, item]}')
                    else:
                        raise StaleExc()
                phase1(item, pends + [lib])
        res.append(lib)
    for lib in libs:
        phase1(lib, [])

    # If both f:func and lib.cc, where f:func is in lib.cc, are listed,
    # remove f:func.  Also, duplication will be removed.
    res2 = []
    for lib in res:
        if lib[:2] != 'f:':
            res2.append(lib)
            continue
        fn = lib[2:]
        if fn not in defAt or defAt[fn] not in res:
            res2.append(lib)
            continue

    # Adds every item to res3, but only if all its dependency have been added.
    notyet = res2
    res3 = []
    while notyet:
        ny = []
        for item in notyet:
            if item not in dep or all([x in res3 for x in dep[item]]):
                res3.append(item)
            else:
                ny.append(item)
        notyet = ny
    return res3

def openStale(path):
    if dcAtime is not None and \
       os.stat(path).st_atime > dcAtime:
        raise StaleExc()
    return open(path)

def addFconts(fconts, libname):
    def firstLine(fp):
        while True:
            line = fp.readline()
            if not line: raise MyExc()
            mo = re.search(magic + r'\s*FUNC\s+BEGIN\s+(\S+)', line)
            if mo: return mo[1]

    def getNextFunc(fp):
        funcname = firstLine(fp)
        cont = ''
        while True:
            line = fp.readline()
            if not line:
                abort(f'No endmark for function {funcname} in {libname}.cc')
            mo = re.search(magic + r'\s*FUNC\s+END', line)
            if mo: return (funcname, cont)
            cont += line

    # log(f'addFconts for {libname}')
    with openStale(f'{topDir}/clib/{libname}.cc') as fp:
        try:
            while True:
                (func, cont) = getNextFunc(fp)
                fconts[func] = cont
                # log(f'addFconts: found {func}')
        except MyExc:
            pass

def doInsert(lib):
    cont = ''
    with openStale(f'{topDir}/clib/{lib}.cc') as fp:
        while True:
            line = fp.readline()
            if not line:
                abort(f'No beginmark in {lib}.cc')
            if re.search(magic + r'\s*BEGIN', line): break
        while True:
            line = fp.readline()
            if not line:
                abort(f'No endmark in {lib}.cc')
            if re.search(magic + r'\s*END', line): break
            cont += line
    return cont

def composite(origLibs):
    # log('composite')
    libs = depSort(origLibs)
    # log('after depSort')
    outs = ''
    fconts = {}
    for lib in libs:
        if lib[:2] == 'f:':
            funcname = lib[2:]
            if funcname not in defAt:
                if dcAtime is None:
                    abort(f'{funcname} is not defined in the library')
                else:
                    raise StaleExc()
            libname = defAt[funcname]
            if lib not in fconts:
                addFconts(fconts, libname)
            if funcname not in fconts:
                abort(f'Definition for {funcname} not found in {libname}')
            outs += f'// ---- inserted function {funcname} from {libname}.cc\n'
            outs += fconts[funcname]
            outs += f'// ---- end {funcname}\n'
        else:
            outs += f'// ---- inserted library file {lib}.cc\n'
            outs += doInsert(lib)
            outs += f'// ---- end {lib}.cc\n'
    return (libs, outs)

def main():
    args = commandLineArgs()

    inLine = sys.stdin.readline()
    mo = re.search(markpat, inLine)
    if not mo:
        abort("first line of stdin does not match the pattern.");
    origLibs = mo[1].split() if mo[1] else []
    if args.file != "NONE": origLibs.append(args.file)

    readCachedDep()
    try:
        (libs, outs) = composite(origLibs)
    except StaleExc:
        # log("STALE")
        buildInfo()
        (libs, outs) = composite(origLibs)

    outProlog = f'''// {magic} LIM({' '.join(origLibs)})
// --> {' '.join(libs)}
'''
    outEpilog = f'''// {magic} LIM  -- end mark --
'''
    print(outProlog + outs + outEpilog, end='')
        
def commandLineArgs():
    parser = argparse.ArgumentParser(
        description='''insert library code

// Dependency spec.  Following double atmarks and double bang marks,
//     put DEPEND(lst) where lst is a space-separated list of lib names,
//     such as DPEND(util tree f:power f:<<)
''');
    parser.add_argument('file', help='basename of the library file');
    return parser.parse_args()

main()
