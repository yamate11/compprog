#!/usr/bin/env python3

import sys, os, argparse, re, json
from util import topDir

magic = '@@ !!'
markpat = magic + r'\s*LIM(?:\s*\((.*)\))?';
depCache = f'{topDir}/clib/.lib_depend'

# dictionary for dependency.
#   If 'lib1' is in dep['lib2'], then lib1.cc is needed for
#   (i.e., must be included ealier than) lib2.cc.
#   If 'f:func' is in dep['lib3'], then function func is needed
#   for lib3.cc.
dep = {}
# definition information.
#   If defAt['f:func'] is 'lib', then f:func is defined in lib.cc.
#   Note that prefix 'f:' appears in keys of defAt.
defAt = {}

class LibExc(Exception):
    pass

def abort(msg):
    print("libins: Fatal: " + msg, file=sys.stderr)
    sys.exit(1)

def log(msg):
    print(msg, file=sys.stderr)

def buildInfo():
    global dep, defAt
    dep = {}
    defAt = {}
    clibdir = f'{topDir}/clib'
    for fn in os.listdir(clibdir):
        if fn[-3:] != '.cc': continue
        libname = fn[:-3]
        path = f'{clibdir}/{fn}'
        dep[libname] = []
        with open(path, 'r') as fp:
            for line in fp:
                mo = re.search(magic + r'\s*BEGIN\s*\((.*)\)', line)
                if mo:
                    dep[libname] = mo[1].split()
                pat = r'\s*FUNC\s+BEGIN\s+(\S+)(?:\s*\((.*)\))?'
                mo = re.search(magic + pat, line)
                if mo:
                    funcname = mo[1]
                    if funcname in defAt:
                        p1 = defAt[funcname]
                        raise LibExc(f'Function {funcname} is defined twice: '
                                     f'{defAt[funcname]} and {libname}');
                    defAt[funcname] = libname
                    if mo[2]:
                        dep[funcname] = mo[2].split()
                    else:
                        dep[funcname] = []
    with open(depCache, 'w') as fp:
        json.dump({'dep': dep, 'defAt': defAt}, fp)
        
def readCachedDep():
    global dep, defAt
    if not os.path.exists(depCache):
        buildInfo()
        return
    dcAtime = os.stat(depCache).st_atime
    clibdir = f'{topDir}/clib'
    for fn in os.listdir(clibdir):
        if fn[-3:] != '.cc': continue
        path = f'{clibdir}/{fn}'
        if os.stat(path).st_atime > dcAtime:
            buildInfo()
            return
    with open(depCache, 'r') as fp:
        info = json.load(fp)
    dep = info['dep']
    defAt = info['defAt']

def depSort(libs):
    # Add all dependent files into res
    visited = set()
    onstack = []
    res1 = []
    def phase1(lib):
        if lib in onstack:
            raise LibExc(f'Dependency loop detected for {lib}')
        if lib in visited:
            return
        visited.add(lib)
        if lib not in dep:
            msg = f'Library or Function {lib} not found.  ' + \
                f'Dependency chain is {onstack}.'
            raise LibExc(msg)
        onstack.append(lib)
        for item in dep[lib]:
            phase1(item)
        x = onstack.pop()
        assert(x == lib)
        if lib[:2] == 'f:':
            if lib not in defAt:
                raise LibExc(f'Definition of Function{lib} not found.')
            if defAt[lib] not in res1:
                res1.append(lib)
        else:
            res1.append(lib)
    for lib in libs:
        phase1(lib)
    # log(f'res1 = {res1}')
    return res1

def doInsert(lib):
    cont = ''
    def readUntil(mark, rec):
        nonlocal cont
        while True:
            line = fp.readline()
            if not line:
                raise LibExc(f'No beginmark in {lib}.cc')
            exp = magic + r'\s*' + mark
            if re.search(exp, line):
                break
            if rec:
                cont += line

    with open(f'{topDir}/clib/{lib}.cc') as fp:
        readUntil('BEGIN', False)
        readUntil('END', True)
    return cont

funcContents = {}

def readToFuncContents(libname):
    global funcContents

    class MyEOF(Exception):
        pass

    def firstLine(fp):
        while True:
            line = fp.readline()
            if not line:
                raise MyEOF()
            mo = re.search(magic + r'\s*FUNC\s+BEGIN\s+(\S+)', line)
            if mo: return mo[1]

    def getNextFunc(fp):
        funcname = firstLine(fp)
        cont = ''
        while True:
            line = fp.readline()
            if not line:
                msg = f'No endmark for function {funcname} in {libname}.cc'
                raise LibExc(msg)
            mo = re.search(magic + r'\s*FUNC\s+END', line)
            if mo: return (funcname, cont)
            cont += line

    with open(f'{topDir}/clib/{libname}.cc') as fp:
        try:
            while True:
                (func, cont) = getNextFunc(fp)
                funcContents[func] = cont
                # log(f'addFconts: found {func}')
        except MyEOF:
            pass

def getFuncContents(funcname):
    libname = defAt[funcname]
    pre = f'\n// ---- inserted function {funcname} from {libname}.cc\n'
    post = f'// ---- end {funcname}\n'
    if funcname not in funcContents:
        readToFuncContents(libname)
        if funcname not in funcContents:
            msg = f'Definition for {funcname} not found in {libname}'
            raise LibExc(msg)
    body = funcContents[funcname]
    return pre + body + post

def getLibContents(libname):
    pre = f'\n// ---- inserted library file {libname}.cc\n'
    body = doInsert(libname)
    post = f'// ---- end {libname}.cc\n'
    return pre + body + post

def composite(origLibs):
    outs = ''
    for libOrFunc in depSort(origLibs):
        if libOrFunc[:2] == 'f:':
            outs += getFuncContents(libOrFunc)
        else:
            outs += getLibContents(libOrFunc)
    return outs

def uniq(lst):
    ret = []
    for x in lst:
        if not x in ret:
            ret.append(x)
    return ret

def main():
    args = commandLineArgs()

    if args.cache_update:
        buildInfo()
        sys.exit(0)

    inLines = sys.stdin.readlines()
    sz = len(inLines)
    (idxFst, idxLast) = (None, None)
    for (idx, line) in enumerate(inLines):
        mo = re.search(markpat, line)
        if mo:
            if idxFst is None:
                idxFst = idx
            idxLast = idx
    if idxFst is None:
        for line in inLines():
            print(line, end='')
        return
    mo = re.search(markpat, inLines[idxFst])
    assert(mo)
    origLibs = mo[1].split() if mo[1] else []
    addLibs = [f for f in args.file if f.lower() != "none"]
    specLibs = uniq(origLibs + addLibs)
    readCachedDep()

    def pout(outs, libs):
        for i in range(idxFst):
            print(inLines[i], end='')
        print(f"// {magic} LIM({' '.join(libs)})")
        if len(libs) > 0:
            print(outs, end='')
            print(f"\n// {magic} LIM -- end mark --")
        for i in range(idxLast + 1, sz):
            print(inLines[i], end='')

    try:
        pout(composite(specLibs), specLibs)
    except LibExc as e:
        pout('', origLibs)
        print(str(e), file=sys.stderr)
        sys.exit(1)
        
def commandLineArgs():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='''libins inserts library code.

It reads a file from stdin and replace the "library insertion
part", which is defined as the part between two "library insertion
lines" (LILs) if the file contains two LILs, and the LIL itself if
it contains one LIL.  The resulted contents will be sent to
stdout.  The contents to be replaced with are the library contents
specified in the first LIL, plus ones given in the command line.
Identifier NONE can be used as a non-effective place holder for a
library name.

If a library specified is not found, an error message is reported
both to stdout and stderr.  If there are no LIL, the output is the
same as the input.  If there are more than two LILs, the first
and the last define the range of the library insertion part.
''');
    parser.add_argument('file', help='basename of library file',
                        nargs='*');
    parser.add_argument('--cache-update', action='store_true',
                        help='only updates the cache and exits.')
    return parser.parse_args()

main()
